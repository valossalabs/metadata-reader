# -*- coding: utf-8 -*-
"""Plotting with matplotlib

This module has all plotting related functions, classes, etc.
Tested with matplotlib 1.5.3 and 2.1.0
"""

from __future__ import print_function, unicode_literals
from __future__ import absolute_import
from __future__ import division

import sys
import datetime
import matplotlib
matplotlib.use("Agg")  # This allows to use without DISPLAY, and prevents usage of DISPLAY
import numpy
import matplotlib.pyplot as plt
import matplotlib.ticker


config = {
    "default_image_size": (640, 640),  # pixels
    "simple_image_size": (640, 100),
    "window_title": "Bar diagram generated by metadatareader",
    "bar_color": "#6eb9db",
    "bar_edge_color": "#6eb9db",  # #80a0ff
    "text_in_bar_color": "#EEEEEE",  # #E3F6FF
    "text_out_bar_color": "#333333",  # #137FB0
    "font": {
        "family": "sans-serif",
        "sans-serif": "roboto",
        "size": 12,
    },
    "red_color": "#eec4ce",  # "#e29c9c",
    "green_color": "#d9eec4",  # "#bfe29c",
    "line_color": "#636b6f",
    "light_red_color": "#f9e7ea",
    "light_green_color": "#ebf8e2",
    "intensity": "#e8d9b0",
}


class MetadataPlotter(object):

    def __init__(self, **kwargs):
        """

        :param kwargs: Arguments used here:
            - 'size_multiplier' (int/float). Image size in inches. Default 5 inch.
            - 'image_size' (int). Image size in pixels. Default in config['default_image_size']
            - 'simple' (bool). Simple plot has different default image size in pixels.
            - 'transparent_bg' (bool). Default True, if one doesn't want transparent background, set this to False.
            - 'output_file' (string). Define name for resulting file. Either this or 'output_format' is needed for
              generating file.
            - 'output_format' (string). Define format for resulting file. Either this or 'output_file' is needed for
              generating file.
        """
        # Setup basic values:

        # -- Image size settings ---------------------------------------------------------------------------------------
        basic_size_inch = kwargs.get("size_multiplier", 5)
        if kwargs.get("image_size") is None:
            kwargs["image_size"] = config["default_image_size"]
        self.dpi = kwargs["image_size"][0] / basic_size_inch
        if kwargs.get("simple"):
            config_im_size = config["simple_image_size"]
        else:
            config_im_size = config["default_image_size"]
        self.width = kwargs.get("image_size", config_im_size)[0] / self.dpi
        self.height = kwargs.get("image_size", config_im_size)[1] / self.dpi

        # -- Miscellaneous settings ------------------------------------------------------------------------------------
        self.transparency = kwargs.get("transparent_bg", True)
        self.number_format = kwargs.get("number_format", "not_seconds")

        if kwargs.get("output_file") is not None:
            self.filename = self._new_filename(filename=kwargs.get("output_file"))
        elif kwargs.get("output_format") is not None:
            self.filename = self._new_filename(file_format=kwargs.get("output_format"))
        else:
            self.filename = None

        # -- Font settings ---------------------------------------------------------------------------------------------
        self.prop = matplotlib.font_manager.FontProperties()
        if "font_file" in kwargs:
            self.prop.set_file(kwargs['font_file'])
        elif "font" in kwargs:  # [font, font_family, size]
            self.prop.set_name(kwargs['font'][0])
            if len(kwargs['font']) > 1:
                self.prop.set_family(kwargs['font'][1])
            if len(kwargs['font']) > 2:
                self.prop.set_size(kwargs['font'][2])
        if "font_size" in kwargs:
            self.prop.set_size(kwargs['font_size'])
        self.ticklabel_prop = self.prop.copy()
        self.ticklabel_prop.set_size(self.prop.get_size() - 2)
        # -- Image title -----------------------------------------------------------------------------------------------
        #if kwargs.get("show_title", False):

        # self.image_title = kwargs.get("show_title", None)

    def plot_simple_sentiment(self, sentiment_data, **kwargs):
        """Plots simple "trinary" bar.

        :param sentiment_data: list of two-cell lists with first cell being time as seconds and second cell
                               being float value between -1 and 1. [second, valence]
        :param kwargs: Arguments used here:
            - 'threshold' (float). 0.2 if None
        :return: filename of plot in list or None
        """
        x = list()
        y = list()
        for cell in sentiment_data:
            x.append(cell[0])
            if cell[1] < -kwargs.get("threshold", 0.2):
                y.append('red')
            elif cell[1] > kwargs.get("threshold", 0.2):
                y.append('green')
            else:
                y.append('gray')
        fig, ax = plt.subplots(
            figsize=(self.width,    # kwargs.get("image_size", config["simple_image_size"])[0] / self.dpi,
                     self.height),  # kwargs.get("image_size", config["simple_image_size"])[1] / self.dpi),
            dpi=self.dpi
        )
        ax.bar(x, height=1.0, width=1.0, color=y)
        plt.axis('off')

        fig.set_tight_layout(True)
        if self.filename is not None:
            try:
                plt.savefig(self.filename, transparent=self.transparency, dpi=self.dpi)
            except ValueError as msg:
                print("Invalid output-file: {}".format(msg), file=sys.stderr)
            else:
                plt.close(fig)
                return [self.filename]
            plt.close(fig)
        else:
            fig.canvas.set_window_title(config["window_title"])

            plt.show()

    def plot_intensity(self, sentiment_data, **kwargs):
        """Plot intensity graph. Assuming intensity values between 0 and 1.

        :param sentiment_data: list of two-cell lists with first cell being time as seconds and second cell
                               being float value between 0 and 1. [second, intensity]
        :param kwargs: Arguments used here:
            - 'video_length' (float). sentiment_data[-1][0] if None
            - 'show_title' (bool). Allows printing title inside plot if True.
            - 'face_sentiment_graph' (bool). Title: Facial sentiment analysis
            - 'transcript_sentiment_graph' (bool). Title: Transcript intensity analysis
        :return: filename of plot in list or None
        """
        if len(sentiment_data) == 0:
            # If no data to print, return empty list
            return []
        # -- Data ------------------------------------------------------------------------------------------------------
        x = list()
        y_zero = list()  # Compare
        y_nan = list()

        for cell in sentiment_data:
            if cell[1] != u'':
                x.append(cell[0])
                # cell[1] should be decimal.Decimal() at this point
                y_zero.append(float(cell[1]))
                y_nan.append(float(cell[1]))
            else:
                x.append(cell[0])
                temp = [tmp for tmp in y_nan if tmp is not numpy.nan][-5:]  # Last five values
                if len(temp) == 0:
                    y_zero.append(0.0)
                else:
                    # Add mean of five previous values:
                    y_zero.append(sum(temp)/float(len(temp)))
                y_nan.append(numpy.nan)

        # -- Figure initialization -------------------------------------------------------------------------------------
        fig = plt.figure(figsize=(self.width, self.height), dpi=self.dpi)
        ax1 = fig.add_subplot(1, 1, 1)
        ax1.spines["right"].set_visible(False)
        ax1.spines["top"].set_visible(False)
        ax1.tick_params(axis='y', right='off')
        ax1.tick_params(axis='x', top='off')
        ax1.tick_params(axis='x', direction='out')
        ax1.tick_params(axis='y', direction='out')

        line_width = 1.0
        ax1.set_ylim(0.0, 1.0)
        ax1.set_xlim(0.0, kwargs.get('video_length', x[-1]))
        plt.yticks([0.0, 0.5, 1.0],  fontproperties=self.ticklabel_prop)
        plt.xticks(fontproperties=self.ticklabel_prop)
        y_zero_smooth = numpy.array(y_zero)
        for i in range(2):
            y_zero_smooth = smooth(y_zero_smooth, window_len=min(9, len(y_zero_smooth)))
        y_nan_smooth = numpy.copy(y_zero_smooth)
        for i, cell in enumerate(y_nan):
            if cell is numpy.nan:
                y_nan_smooth[i] = numpy.nan

        ax1.plot(numpy.array(x), y_nan_smooth, color=config['line_color'], zorder=10, linewidth=line_width,
                 label="Intensity")

        # -- Filling ---------------------------------------------------------------------------------------------------
        d = numpy.zeros(len(x))
        ax1.fill_between(x, d, y_nan, color=config['intensity'])

        # -- Legend ----------------------------------------------------------------------------------------------------
        valence_line = matplotlib.lines.Line2D(
            [], [],
            color=config['line_color'],
            marker='_',
            markersize=10,
            label="Intensity",
        )
        legend_patch = [valence_line]

        # -- Legend location: ------------------------------------------------------------------------------------------
        # Shrink current axis's height by 10% on the bottom
        box = ax1.get_position()
        ax1.set_position([box.x0, box.y0 + box.height * 0.15,
                          box.width, box.height * 0.85])
        # Put a legend below current axis
        ax1.legend(handles=legend_patch, loc='upper center', bbox_to_anchor=(0.5, -0.15),
                   fancybox=True, shadow=True, ncol=5, prop=self.ticklabel_prop)

        # -- Title -----------------------------------------------------------------------------------------------------
        if kwargs.get("show_title", False):
            if kwargs.get("face_sentiment_graph", False):
                #plt.title("Facial sentiment analysis", fontproperties=self.prop)
                plt.title(kwargs.get("video_title", "Facial sentiment analysis"), fontproperties=self.prop)
            if kwargs.get("transcript_sentiment_graph", False):
                plt.title(kwargs.get("video_title", "Transcript intensity analysis"), fontproperties=self.prop)

        if self.filename is not None:
            try:
                plt.savefig(self.filename, transparent=self.transparency, bbox_inches='tight', dpi=self.dpi)
            except ValueError as msg:
                print("Invalid output-file: {}".format(msg), file=sys.stderr)
            else:
                plt.close(fig)
                return [self.filename]
            plt.close(fig)

        else:
            fig.canvas.set_window_title(config["window_title"])

            plt.show()

    def plot_sentiment(self, sentiment_data, **kwargs):
        """Plot valence graph or valence/intensity combination graph.

        :param sentiment_data: Either list of two cell lists or three cell lists. First cell is seconds, second cell is
                               valence and optional third cell is intensity. [second, valence, intensity]
        :type sentiment_data: list
        :param kwargs: Arguments used here:
            - 'simple' (bool). Call plot_simple_sentiment() -method if True.
            - 'video_length' (float), sentiment_data[-1][0] if None
            - 'show_title' (bool). Allows printing title inside plot if True.
            - 'face_sentiment_graph' (bool). Title: Facial sentiment analysis
            - 'transcript_sentiment_graph' (bool). Title: Transcript intensity analysis
        :return: filename of plot in list or None
        :rtype: list[str]
        """
        if len(sentiment_data) == 0:
            # If no data to print, return empty list
            return []

        if kwargs.get("simple", False):
            self.plot_simple_sentiment(sentiment_data, **kwargs)
            return
        if len(sentiment_data[0]) > 2:
            intensity = True
        else:
            intensity = False

        # -- Data ------------------------------------------------------------------------------------------------------
        x = list()
        y_zero = list()  # Compare
        y_avg = list()
        y_nan = list()
        if intensity:
            green_y = list()
            red_y = list()
        for cell in sentiment_data:
            if cell[1] != u'':
                x.append(cell[0])
                y_zero.append(cell[1])
                y_avg.append(cell[1])
                y_nan.append(cell[1])
                if intensity:
                    green_y.append(cell[1]/2.0+cell[2])
                    red_y.append(cell[1]/2.0-cell[2])
            else:
                x.append(cell[0])
                temp = [tmp for tmp in y_nan if tmp is not numpy.nan][-5:]
                if len(temp) == 0:
                    y_avg.append(0.0)
                else:
                    # Add mean of five previous values:
                    y_avg.append(sum(temp) / float(len(temp)))
                y_zero.append(0.0)
                y_nan.append(numpy.nan)
                if intensity:
                    green_y.append(0.0)
                    red_y.append(0.0)

        # -- Smooth ----------------------------------------------------------------------------------------------------
        y_avg_smooth = numpy.array(y_avg)
        smoothened = False
        for i in range(2):
            smoothened = True
            y_avg_smooth = smooth(y_avg_smooth, window_len=min(7, len(y_avg_smooth)-1))  # Perhaps use window length based on video length?
        y_nan_smooth = numpy.copy(y_avg_smooth)
        for i, cell in enumerate(y_nan):
            if cell is numpy.nan:
                y_nan_smooth[i] = numpy.nan

        # -- Figure ----------------------------------------------------------------------------------------------------
        print("Image size:", self.width, self.height, "DPI:", self.dpi)
        fig, ax1 = plt.subplots(figsize=(self.width, self.height), dpi=self.dpi)
        ax1.spines["right"].set_visible(False)
        ax1.spines["top"].set_visible(False)
        ax1.tick_params(axis='y', right='off')
        ax1.tick_params(axis='x', top='off')
        ax1.tick_params(axis='x', direction='out')
        ax1.tick_params(axis='y', direction='out')
        if intensity:
            line_width = 1.3
        else:
            line_width = 1.0
        ax1.set_ylim([-1.05, 1.05])
        ax1.set_xlim(0.0, kwargs.get('video_length', x[-1]))
        plt.yticks([-1.0, 1.0], ['negative', 'positive'], fontproperties=self.ticklabel_prop)
        plt.xticks(fontproperties=self.ticklabel_prop)

        ax1.plot(numpy.array(x), y_nan_smooth, color=config['line_color'], zorder=10, linewidth=line_width,
                 label="Valence")

        valence_line = matplotlib.lines.Line2D([], [], color=config['line_color'], marker='_',
                                               markersize=10, label="Valence")
        legend_patch = [valence_line]

        # -- Fill colors -----------------------------------------------------------------------------------------------
        d = numpy.zeros(len(x))
        if intensity:  # audio.speech usually
            ax1.fill_between(x, green_y, where=green_y > d, interpolate=True, color=config['green_color'], zorder=4)
            ax1.fill_between(x, red_y, where=red_y < d, interpolate=True, color=config['red_color'], zorder=4)
            legend_patch.extend([matplotlib.patches.Patch(color=config['green_color'], label='Positive words'),
                                 matplotlib.patches.Patch(color=config['red_color'], label='Negative words')])
        else:  # human.face usually

            if not smoothened:
                ax1.fill_between(x, 0, y_zero, where=y_zero > d, interpolate=True, color=config['green_color'])
                ax1.fill_between(x, 0, y_zero, where=y_zero < d, interpolate=True, color=config['red_color'])
            else:
                y_green = numpy.minimum(y_avg_smooth, numpy.array(y_zero))
                y_green_nan = [a if a is numpy.nan else b for (a, b) in zip(y_nan, y_green)]
                ax1.fill_between(x, 0, y_green_nan, where=y_green > d, color=config['green_color'], zorder=2)
                ax1.fill_between(x, 0, y_avg, where=y_zero > d, interpolate=True, color=config['green_color'], zorder=1, alpha=0.35)

                y_red = numpy.maximum(y_avg_smooth, numpy.array(y_zero))
                y_red_nan = [a if a is numpy.nan else b for (a, b) in zip(y_nan, y_red)]
                ax1.fill_between(x, 0, y_red_nan, where=y_red < d, color=config['red_color'], zorder=2)
                ax1.fill_between(x, 0, y_avg, where=y_zero < d, interpolate=True, color=config['red_color'], zorder=1, alpha=0.35)

        # -- Legend location: ------------------------------------------------------------------------------------------
        # Shrink current axis's height by 15% on the bottom
        box = ax1.get_position()
        ax1.set_position([box.x0, box.y0 + box.height * 0.15,
                          box.width, box.height * 0.85])
        # Put a legend below current axis
        ax1.legend(handles=legend_patch, loc='upper center', bbox_to_anchor=(0.5, -0.15),
                   fancybox=True, shadow=True, ncol=5, prop=self.ticklabel_prop)

        # -- Title -----------------------------------------------------------------------------------------------------
        if kwargs.get("show_title", False):
            if kwargs.get("face_sentiment_graph", False):
                plt.title(kwargs.get("video_title", "Facial sentiment analysis"), fontproperties=self.prop)
            if kwargs.get("transcript_sentiment_graph", False):
                plt.title(kwargs.get("video_title", "Transcript sentiment analysis"), fontproperties=self.prop)

        # -- Save plot into file ---------------------------------------------------------------------------------------
        if self.filename is not None:
            try:
                plt.savefig(self.filename, transparent=self.transparency, bbox_inches='tight', dpi=self.dpi)
            except ValueError as msg:
                print("Invalid output-file: {}".format(msg), file=sys.stderr)
            else:
                plt.close(fig)
                return [self.filename]
            plt.close(fig)

        else:
            fig.canvas.set_window_title(config["window_title"])
            plt.show()

    def plot_barh(self, amounts, labels, **kwargs):
        """Plot horizontal bar chart.

        kwargs can include `title`, `filename`

        :param amounts: list of amounts, used as bar width.
        :param labels: list of labels associated with amounts.
        :param kwargs: Arguments used here:
            - 'font_file' (string). Set the filename of the fontfile to use. In this case, all other properties will be
              ignored.
            - 'font' (list). List of font, font_family and font size or None.
            - 'font_size' (int/string). Font size overrides size given in 'font'.
            - 'strict_n' (bool). Prevents scaling of the plot caused if there are less labels than given n.
            - 'image_size' (list/tuple). If not given, this plot has own default height value depending on amount of
              labels. len(labels) / 3 + 2 as inches
            - 'sort_method' (string). If string 'count', amounts are not seconds. Else assume that amounts are seconds.
            - 'video_length' (float). Calculate percent labels for bars.
            - 'time_label' (string). If string 'timestamp_and_percent' and video_length is given, print 'hh:mm:ss (xx%)'
              into bar. If string 'percent' and video_length is given, print 'xx%' into bar. Else print 'hh:mm:ss' into
              bar.
            - 'title' (string). If not None, print contained string into plot.
            - 'label_location' (string). If string 'left_side', print labels left side of plot. Otherwise print labels
              on bar if bar is wide enough, else right side of bar.
        :return: filename of plot in list or None
        """
        # if "filename" in kwargs:
        #     # This allows to use without DISPLAY
        #     import matplotlib
        #     matplotlib.use("Agg")
        if len(labels) == 0:
            # If no labels to print, return empty list.
            return []
        if kwargs.get("strict_n", False):
            while len(amounts) < kwargs.get("n_most_prominent_detections_per_type", len(amounts)):
                amounts.append(0)
                labels.append("")

        # Override default value:
        if "image_size" not in kwargs:
            self.height = len(labels) / 3 + 2

        fig, ax = plt.subplots(figsize=(self.width, self.height), dpi=self.dpi)
        ax.spines["right"].set_visible(False)
        ax.spines["top"].set_visible(False)
        ax.xaxis.set_ticks_position("bottom")
        ax.tick_params(axis='y',
                       which='both',
                       left='off',
                       right='off')
        ax.tick_params(axis='x',
                       direction='out')
        ax.set_yticklabels([])

        def delta_formatter(x, pos):
            """Custom formatter

            :param x: a tick value as seconds
            :param pos: a position (required even if unused)
            :return: corresponding tick label
            """
            if kwargs.get("sort_method", None) == "count":
                return int(x)

            if self.number_format == "seconds":
                format_string = u'{}'.format(int(x))
                return format_string
            d = datetime.timedelta(seconds=x)
            format_string = u'{}'.format(str(d))
            return format_string

        def time_label_formatter(x, pos):
            """Custom formatter time_label: ['timestamp', 'timestamp_and_percent', 'percent']

            :param x: a tick value as seconds
            :param pos: a position (required even if unused)
            :return: corresponding tick label
            """
            if kwargs.get("sort_method", None) == "count":
                return int(x)
            if kwargs.get('video_length') is not None:
                percent = 100.0*x/kwargs['video_length']
                if percent > 100.0:
                    n = 0
                    percent = 100.0
                elif percent > 10.0:
                    n = 0
                elif percent > 1.0:
                    n = 1
                elif percent > 0.1:
                    n = 2
                else:
                    n = 3
            else:
                percent = None

            if kwargs.get("time_label") is not None:
                if kwargs["time_label"] == "timestamp_and_percent" and percent is not None:
                    format_string = u'{}, {:.{n}f}%'.format(str(datetime.timedelta(seconds=x)), percent, n=n)
                elif kwargs["time_label"] == "percent" and percent is not None:
                    format_string = u'{:.{n}f}%'.format(percent, n=n)
                else:  # kwargs["time_label"] == "timestamp":
                    format_string = str(datetime.timedelta(seconds=x))
            elif kwargs.get('video_length') is not None:
                format_string = u'{:.{n}f}%'.format(percent, n=n)
            else:
                format_string = str(datetime.timedelta(seconds=x))
            return format_string

        ax.locator_params(axis='x', nbins=kwargs.get('max_ticks', 6), integer=True)

        formatter = matplotlib.ticker.FuncFormatter(delta_formatter)
        ax.xaxis.set_major_formatter(formatter)
        plt.xticks(fontproperties=self.ticklabel_prop)

        if "title" in kwargs:
            plt.title(kwargs["title"], fontproperties=self.prop)

        # amounts is the amount of rest of the labels
        y = numpy.arange(len(amounts)) + 0.5
        rects = ax.barh(y, amounts,
                        edgecolor=kwargs.get("bar_color", config["bar_edge_color"]),
                        color=kwargs.get("bar_color", config["bar_color"]),
                        align="center")
        text_in_bar_color, text_out_bar_color = text_color(kwargs.get("bar_color", config["bar_color"]))

        # ax.set_xlabel("Total detection duration")
        if kwargs.get("label_location") == "left_side":
            plt.yticks(y, labels)
        bar_width = int(rects[0].get_width())
        for index, rect in enumerate(rects):
            width = rect.get_width()
            yloc = rect.get_y() + rect.get_height() * 0.5
            if kwargs.get("label_location") == "left_side":
                if width > bar_width * 0.5:
                    xloc = width * 0.98
                    align = "right"
                    #color = config["text_in_bar_color"]
                    color = text_in_bar_color
                else:
                    xloc = width + bar_width / 100.0
                    align = "left"
                    #color = config["text_out_bar_color"]
                    color = text_out_bar_color

                ax.text(xloc, yloc, time_label_formatter(int(width), None), horizontalalignment=align,
                        verticalalignment='center', color=color, weight='bold',
                        fontproperties=self.prop)
            else:  # on_bar

                # -- Label in bar, left alignment; Percent in bar, right alignment -------------------------------------
                if width > bar_width * 0.75:
                    xloc_label = bar_width * 0.02
                    xloc = width - bar_width * 0.02
                    label_color = text_in_bar_color  # config["text_in_bar_color"]
                    color = text_in_bar_color  # config["text_in_bar_color"]
                    label_align = "left"
                    ax.text(xloc, yloc, time_label_formatter(int(width), None), horizontalalignment="right",
                            verticalalignment='center', color=color, weight='bold',
                            fontproperties=self.prop)

                # -- Label in bar, left alignment; Percent outside bar, left alignment ---------------------------------
                elif width > bar_width * 0.5:
                    xloc_label = bar_width * 0.02
                    xloc = width + bar_width * 0.02
                    label_color = text_in_bar_color  # config["text_in_bar_color"]
                    color = text_out_bar_color  # config["text_out_bar_color"]
                    label_align = "left"
                    ax.text(xloc, yloc, time_label_formatter(int(width), None), horizontalalignment="left",
                            verticalalignment='center', color=color, weight='bold',
                            fontproperties=self.prop)

                # -- Label outside bar, left alignment; Percent inside bar, right alignment ----------------------------
                elif width > bar_width * 0.1:
                    xloc_label = width + bar_width * 0.02
                    xloc = width - bar_width * 0.02
                    label_color = text_out_bar_color  # config["text_out_bar_color"]
                    color = text_in_bar_color  # config["text_in_bar_color"]
                    label_align = "left"
                    ax.text(xloc, yloc, time_label_formatter(int(width), None), horizontalalignment="right",
                            verticalalignment='center', color=color, weight='bold',
                            fontproperties=self.prop)

                # -- Label outside bar, left alignment; Percent not visible --------------------------------------------
                else:  # width <= bar_width * 0.5
                    xloc_label = width + bar_width * 0.02
                    label_color = text_out_bar_color  # config["text_out_bar_color"]
                    label_align = "left"
                ax.text(xloc_label, yloc, labels[index], horizontalalignment=label_align,
                        verticalalignment='center', color=label_color, weight='bold',
                        fontproperties=self.prop)

        fig.gca().invert_yaxis()
        fig.set_tight_layout(True)

        if self.filename is not None:
            try:
                plt.savefig(self.filename, transparent=self.transparency, dpi=self.dpi)
            except ValueError as msg:
                print("Invalid output-file: {}".format(msg), file=sys.stderr)
            else:
                plt.close(fig)
                return [self.filename]
            plt.close(fig)
        else:
            fig.canvas.set_window_title(config["window_title"])

            plt.show()

    @staticmethod
    def _new_filename(prefix="image_bar_", suffix="", file_format=None, filename=None):
        """Creates timestamp'd filename.

        Commented out: Prevents overwriting existing file by adding (i) to filename

        :param prefix: If file_format given, starts file name with this.
        :param suffix: if file_format given, ends file name with this.
        :param file_format: Use this as extension or type for the file.
        :param filename: Ignore this method if this is given, unless overwriting protection is restored.
        :return: name for the file.
        """
        if filename:
            pass
        elif file_format:
            timestamp = str(datetime.datetime.now()).replace(":", ".").replace(" ", "_")
            filename = "{}{}{}.{}".format(prefix, timestamp, suffix, file_format)
        else:
            return None

        # Prevent overwriting existing file by adding (i) to filename
        # name, ext = filename.rsplit(".", 1)
        # i = 1
        # while os.path.exists(filename):
        #     filename = "{}({}).{}".format(name, i, ext)
        #     i += 1
        return filename

    @staticmethod
    def new_filename(**kwargs):
        """
        :param kwargs: Arguments used here:
            - 'prefix' (string).
            - 'suffix' (string).
            - 'file_format' (string).
            - 'filename' (string).
        :return: name for the file
        """
        return MetadataPlotter._new_filename(**kwargs)

    def plot(self, summary, **kwargs):
        """Method to call when intending to plot something.


        :param summary: For bar_summary, list_summary -generator.
                        For sentiment graphs, list_sentiment -generator
        :param kwargs: Arguments used here:
            - 'bar_summary' (bool).
            - 'transcript_sentiment_graph' (bool).
            - 'face_sentiment_graph' (bool).
            - 'output_file' (string). Modifies the value for sentiment graphs.
        :return: File paths and names for successfully created images.
        :rtype: list
        """
        saved_files = list()
        if kwargs.get("bar_summary"):
            labels = []
            amounts = []
            for cells in summary.itervalues():
                for cell in cells:
                    labels.append(cell[0])
                    amounts.append(float(cell[1]))
                try:
                    saved_files.extend(self.plot_barh(amounts, labels, **kwargs))
                except TypeError:
                    pass
        headers = None
        sentiment_data = None
        if kwargs.get("transcript_sentiment_graph"):
            headers = next(summary)
            sentiment_data = [x for x in summary]  # Generator to list
            if 'speech valence' not in headers:
                print("Error: The metadata does not have speech valence data", file=sys.stderr)
            else:
                # Speech:
                # speech_data = second, valence, intensity
                speech_valence = [[x[0], x[2]] for x in sentiment_data]
                speech_intensity = [[x[0], x[3]] for x in sentiment_data]
                split_file = kwargs.get("output_file").rsplit('.', 1)
                self.filename = '.'.join(['_'.join([split_file[0], "ts_val"]), split_file[1]])
                try:
                    saved_files.extend(self.plot_sentiment(speech_valence, **kwargs))
                except TypeError:
                    pass
                self.filename = '.'.join(['_'.join([split_file[0], "ts_int"]), split_file[1]])
                try:
                    saved_files.extend(self.plot_intensity(speech_intensity, **kwargs))
                except TypeError:
                    pass

        if kwargs.get("face_sentiment_graph"):
            if headers is None:
                headers = next(summary)
                sentiment_data = [x for x in summary]
            if 'speech valence' not in headers:
                i = 2
            else:
                i = 4

            # First generate the average-image
            split_file = self.filename.rsplit('.',1)
            facial_data = []
            for item in sentiment_data:
                _sum = sum(0 if j == "" else j for j in item[i:])
                _amount = sum(isinstance(j, float) for j in item[i:])
                _value = _sum/_amount if _amount != 0 else u''
                facial_data.append((item[0], _value))
            self.filename = '.'.join(['_'.join([split_file[0], "face_average"]), split_file[1]])

            while True:
                try:
                    saved_files.extend(self.plot_sentiment(facial_data, **kwargs))
                except TypeError as e:
                    print("ERROR", e, file=sys.stderr)
                    raise
                    pass
                try:
                    facial_data = [[x[0], x[i]] for x in sentiment_data]
                except IndexError:
                    break
                self.filename = '.'.join(['_'.join([split_file[0], "face", headers[i].rsplit(' ', 1)[1]]), split_file[1]])
                i += 1

        return saved_files

def text_color(bar_color):
    """Returns text_in_bar and text_out_bar colors"""

    while bar_color[0] == "#":
        bar_color = bar_color[1:]
    if len(bar_color) != 6:
        raise ValueError("input #{} is not #RRGGBB format".format(bar_color))
    red, green, blue = bar_color[:2], bar_color[2:4], bar_color[4:]
    red, green, blue = [int(n, 16) for n in (red, green, blue)]
    dark_r, dark_g, dark_b = [n//2 for n in (red, green, blue)]
    light_r, light_g, light_b = [(255-(255-n)//6) for n in (red, green, blue)]
    text_in_bar = "#%02x%02x%02x" % (light_r, light_g, light_b)
    text_out_bar = "#%02x%02x%02x" % (dark_r, dark_g, dark_b)
    return text_in_bar, text_out_bar

# Source: http://scipy-cookbook.readthedocs.io/items/SignalSmooth.html
def smooth(x, window_len=11, window='hanning'):
    """smooth the data using a window with requested size.

    This method is based on the convolution of a scaled window with the signal.
    The signal is prepared by introducing reflected copies of the signal
    (with the window size) in both ends so that transient parts are minimized
    in the begining and end part of the output signal.

    input:
        x: the input signal
        window_len: the dimension of the smoothing window; should be an odd integer
        window: the type of window from 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'
            flat window will produce a moving average smoothing.

    output:
        the smoothed signal

    example:

    t=linspace(-2,2,0.1)
    x=sin(t)+randn(len(t))*0.1
    y=smooth(x)

    see also:

    numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve
    scipy.signal.lfilter

    TODO: the window parameter could be the window itself if an array instead of a string
    NOTE: length(output) != length(input), to correct this: return y[(window_len/2-1):-(window_len/2)] instead of just y.
    """

    if x.ndim != 1:
        raise ValueError("smooth only accepts 1 dimension arrays.")

    if x.size < window_len:
        raise ValueError("Input vector needs to be bigger than window size.")

    if window_len < 3:
        return x

    if not window in ['flat', 'hanning', 'hamming', 'bartlett', 'blackman']:
        raise ValueError("Window is on of 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'")

    s = numpy.r_[x[window_len - 1:0:-1], x, x[-2:-window_len - 1:-1]]
    if window == 'flat':  # moving average
        w = numpy.ones(window_len, 'd')
    else:
        w = eval('numpy.' + window + '(window_len)')

    y = numpy.convolve(w / w.sum(), s, mode='valid')

    # Taking advantage of the NOTE above:
    #return y
    return y[(window_len / 2 - 0):-(window_len / 2 - 1 + window_len%2)]
